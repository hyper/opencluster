The client and servers will use a binary protocol to communicate.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTE:   

During implementation of this protocol it became apparent that there are some 
performance advantages in knowing if a message is a command or a reply.

So the 'unused' field we included for padding will be used to indicate this.  If 
it is 0, then it is a command, if it is not zero, then it shows the command that 
this is a reply to, which can be used as an additional check that the messages 
haven't gotten out of sync.

In addition to using the 'unused' field, we moved it to be the second part of the 
message instead of the first.

So now it is:
 2 bytes - command
 2 bytes - command being replied to.
 4 bytes - user specified id.
 4 bytes - length of payload.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



The binary protocol is designed with performance in mind, but is still required to be 
flexible so that future changes to the protocol do not result in clients and servers 
of different versions being unable to communicate with each other.

Therefore some struct rules regarding future changes is required.
  1.  When a protocol command or reply is published, changes will not be made to those 
      operations.
  2.  If new functionality is required, new commands (and possibly replies) are required.  
      Do not make changes (or even expand) existing commands and replies.  Do not add new 
      replies to an existing command.
  3.  If you want different data in a reply from an existing command, then you need to 
      create a new command.  When a client submits a command, it expects the certain 
      replies to be in a particular format, and should not recieve something different.

Communications are broken up into two steps.  A 'command' which could otherwise be 
called a request, and a 'Reply'.   A command should always result in a single reply.   
If a command should result in a number of logical peices (such as retrieving a full 
map), then those peices would be wrapped in a container within the reply.  

All integers are to be transmitted using network-byte-order.
All strings are transmitted with a 4-byte int which indicates the length of the string, followed by
the string data itself.  Strings are not null-terminated.

All communications begin with an 12-byte header.
   ---------------------------------------------------------------------------------
   |   Short Int   | 2 bytes |  Command (or Reply) Identifier                      |
   |   Short Int   | 2 bytes |  Command being replied to (0 if not a reply)        |
   |   Integer     | 4 bytes |  User specified ID                                  |
   |   Integer     | 4 bytes |  Length of the data following this header           |
   ---------------------------------------------------------------------------------

All commands require a reply.  A reply takes the same format as a command, and has the same
12-byte header.  A command can generate different replies as needed.  A single 'command' will always 
return a single 'reply', although it may trigger further commands to come.  The reply will include 
a param that indicates the commandID that it is replying to.

The commands are:
  10    hello        initiate communications.
  11    capabilities determine if a command is accepted or not, without issuing the command.
  15    shuttingdown tells the other node that this node is shutting down and not to send any 
                     buckets to it, or other data.
  20    goodbye      terminate communications cleanly
  30    ping         check that the node is responding.
  50    serverhello  when a server is connecting to another server.
  100   serverlist   sends a list of servers in the cluster.
  110   hashmasks    list of all the hashmasks that are in the system.
  120   maskupdate   when a set of hashes is being moved to a different server, let the clients and
                     other servers know. 
  130   newserver    when a new server joins the cluster, a message is sent out to the other
                     members of the cluster.
  200   loadlevel    nodes will let other nodes know how full they are.
  1000  lock         obtain a cluster lock
  1010  unlock       release a cluster lock
  2000  set_int      set an integer (32-bit) key/value, overwriting if it exists.
  2010  set_long     set an long (64-bit) key/value, overwriting it it exists.
  2020  set_string   set a variable length string key/value.
  2100  get_int      get a integer (32-bit) key/value pair.
  2110  get_long     get a long (32-bit) key/value pair.
  2120  get_string   get a variable length string key/value.
  2200  get_type     get the type of the data.

Note: To promote performance on the server, CommandID's less than 1000 do not require access to the
      clustered data.  CommandID's over 1000 internally require pipeline locks and need to be done
      in sequence.  The sub-1000 commands do not, and can be handled without going through the more
      expensive processing pipeline.




DATA PRIMITIVES

Different kinds of data can be stored in the cluster.  Several primitives are handled directly.  
In the event that these primitives are not enough, anything can be stored as a binary blob, which 
can be any kind of serialized object.  If you serialize using a portable object notation (such as 
POF, JSON, etc), you can put whatever complex objects that you want in there.

Hint:
    These data types are also used for parameter passing in network operations.
    

	+---------+------------+---------------------------------------------------------------------------+
	| Type    | Bytes      | Details                                                                   |
	+---------+------------+---------------------------------------------------------------------------+
	| Short   |  2         | A 16-bit integer, only used in command parameters.  Not a storable type.  |
	| Integer |  4         | A regular (32-bit) integer, signed.                                       |
	| Long    |  8         | A long (64-bit) integer, signed.                                          |
	| String  |  4 + data  | A variable length string. Integer is the length, followed by the data.    |
	+---------+------------+---------------------------------------------------------------------------+







MESSAGE STRUCTURES.

Note that some messages are commands, and some are replies.


-----------------------------------------------------------------------
ack (1)

General acknowlegement.  Used when no data is returned.

Type of message:
  Reply

Conditions of use:
  Sent from either client or server. 

Payload:
  none



-----------------------------------------------------------------------
fail (2)

General failure reply.  Used when no data is returned.

Type of message:
  Reply

Conditions of use:
  Sent from either client or server. 

Payload:
  none


-----------------------------------------------------------------------
failinfo (3)

General failure reply, to indicate that something failed, but this time return an error code and a
descriptive string.

Type of message:
  Reply

Conditions of use:
  Sent from either client or server. 

Payload:
  integer - error code.  
  string  - descriptive string of the failure.


-----------------------------------------------------------------------
tryelsewhere (4)

This reply is returned when the command was not successful because the server is not responsible
for the data requested. This can be because the server is leaving the cluster, or because the data
has moved around and is now on a different node.
 
It contains the information of a different server to try.

Type of message:
  Reply

Conditions of use:
  Sent from server to client. 

Payload:
  string - server to use

In response of:
  hello(10), if the server is shutting down, or not accepting client connections.



-----------------------------------------------------------------------
unknown (9)

This reply is returned when the command was not known on the server.  If the 
client is using a newer protocol that has newer commands, and it sends one to a 
server that doesn't understand it, the server will send this reply.  The client 
library will need to be smart enough to handle these capabilities correctly.  

This is only to be used as a reply.  There should be no such thing as a 'reply' 
that is not known.

Type of message:
  Reply

Conditions of use:
  Sent from server to client. 
  Sent from server to server. 
  Sent from client to server. 

Payload:
  short int - command that was attempted.

In response of:
  any command that it doesn't recognise.






-----------------------------------------------------------------------
hello (10)

This command is used by clients when they connect to a node. 
It does not contain any additional information, so it remains merely a header.
Calling a 'hello' will also result in 'serverlist' and 'hashmasks' information to follow as
seperate commands to the client.

Type of message:
  Command

Conditions of use:
  Sent from client to server. 

Payload:
  none

Replies:
  ack(1), on success.
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.




-----------------------------------------------------------------------
capabilities (11)

This command is used by clients and servers to ensure that the other end knows certain 
commands.  By providing the commandID, the server will respond with an 'ack', or an 'unknown' 
depending on if it knows it or not.   This can be used to avoid using certain commands 
the server doesn't know how to handle.


Type of message:
  Command

Conditions of use:
  Sent from client to server. 
  Sent from server to client.
  Sent from server to server.

Payload:
  short int - command

Replies:
  ack(1), if the command is accepted.
  fail(2), if the command is not known.



-----------------------------------------------------------------------
shutting down (15)

This command is used by server to tell other nodes that it is shutting down. 

It does not contain any additional information, so it remains merely a header.
When an ack(1) is received.

When a node receives this command from another node, it will mark that node as shutting down and 
will not attempt to move buckets to it, will remove that node as a backup to any other buckets.  It 
will also mark the node to not try and connect to it for a while.

Type of message:
  Command

Conditions of use:
  Sent from server to server.

Payload:
  none

Replies:
  ack(1), there is no failure condition that will mean anything.





-----------------------------------------------------------------------
goodbye (20)

This command is used by servers or clients to indicate that the connection is about to be
dropped. 

It does not contain any additional information, so it remains merely a header.
When an ack(1) is received, the connection can be closed.
If this is sent from a client, it will cause all registered events for this client to be cleared,
buffers to be reduced, and so on.  If the client sends a goodbye and then changes its mind, its
capabilities will be diminished, and the server may drop the connection anyway.
If this is sent from a server to a client, it will attempt to wait for an ack(1) from the client,
but if the client takes too long to respond, it will drop the connection anyway.
If this is sent from a server to a server, then certain synchronisations should already be in
place, but any that are outstanding will need to be resolved.

Type of message:
  Command

Conditions of use:
  Sent from client to server. 
  Sent from server to client.
  Sent from server to server.

Payload:
  none

Replies:
  ack(1), there is no failure condition that will mean anything.





-----------------------------------------------------------------------
ping(30)

This command is used to ensure that the server node is responding.  The client can send it
periodically if it wants, and the servers will send it to each other from time to time.


Type of message:
  Command

Conditions of use:
  Sent from client to server. 
  Sent from server to server.

Payload:
  none

Replies:
  ack(1), there is no failure condition that will mean anything.





-----------------------------------------------------------------------
serverhello(50)

This command is used by a server when it is connecting to another server.  It will include the
connection string so that the cluster can publish it to clients and other servers. 

Type of message:
  Command

Conditions of use:
  Sent from server to server.

Payload:
  string - connect info (normally in the form "IP:port", but can be any resolvable standard format)

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.




-----------------------------------------------------------------------
serverlist(100)

Sends a list of servers in the cluster.

Type of message:
  Command

Conditions of use:
  Sent from server to server.
  Sent from server to cient.

Payload:
  integer - count of the servers in the cluster
  string ( x count) - connect info (normally in the form "IP:port", but can be any resolvable
standard format)

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.



-----------------------------------------------------------------------
hashmasks(110)

Sends a list of the hashmasks that this server is responsible for, including backup buckets.
The mask also acts as a count and you should expect two integers for each mask.  If the mask 
is 256 (0xFF), then that means that there are 256 hashmask entries.

Type of message:
  Command

Conditions of use:
  Sent from server to server.
  Sent from server to client.

Payload:
  integer - mask
  integer - buckets in the following list.
  row * mask:
     integer - hashmasks
     integer - instance count (0 = primary, 1 or more = backup).

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.


-----------------------------------------------------------------------
hashmask(120)

Sends an updated hashmask.

Type of message:
  Command

Conditions of use:
  Sent from server to server.
  Sent from server to client.

Payload:
  integer - mask
  integer - hash:
  integer - instance count (0 = primary, 1 or more = backup).

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.


-----------------------------------------------------------------------
set_int(2000)

Set an integer (32-bit) key/value, overwriting if it exists.

Payload:
  integer - map hash (0 for non-map items)
  integer - key hash
  integer - expires (in seconds from now, 0 means it never expires)
  integer - full wait (0 indicates dont wait for sync to backup servers, 1 indicates to wait).
  string  - name
  integer - value (to be stored).

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.



-----------------------------------------------------------------------
  2010  set_long     set an long (64-bit) key/value, overwriting it it exists.
  2020  set_string   set a variable length string key/value.
-----------------------------------------------------------------------
get_int(2100)

get a integer (32-bit) key/value pair.

Payload:
  integer - map hash (0 for non-map items)
  integer - key hash

Replies:
  data_int(2105), return the integer data.
  nack(), if that data doesnt exist or has been expired.
  tryelsewhere(4), if the bucket is being served by a different server.
  

-----------------------------------------------------------------------
data_int(2105)

The integer result from a key lookup

Reply.

Payload:
  integer - map hash (0 for non-map items)
  integer - key hash
  integer - value

  

-----------------------------------------------------------------------
  2110  get_long     get a long (32-bit) key/value pair.
  2120  get_string   get a variable length string key/value.
  2200  get_type     get the type of the data.


-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------



