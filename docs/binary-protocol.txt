The client and servers will use a binary protocol to communicate.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NOTE:   

During implementation of this protocol it became apparent that there are some 
performance advantages in knowing if a message is a command or a reply.

So the 'unused' field we included for padding will be used to indicate this.  If 
it is 0, then it is a command, if it is not zero, then it shows the command that 
this is a reply to, which can be used as an additional check that the messages 
haven't gotten out of sync.

In addition to using the 'unused' field, we moved it to be the second part of the 
message instead of the first.

So now it is:
 2 bytes - command
 2 bytes - command being replied to.
 4 bytes - user specified id.
 4 bytes - length of payload.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



The binary protocol is designed with performance in mind, but is still required to be 
flexible so that future changes to the protocol do not result in clients and servers 
of different versions being unable to communicate with each other.

Therefore some struct rules regarding future changes is required.
  1.  When a protocol command or reply is published, changes (including behaviour) will not be made 
      to those operations.
  2.  If new functionality is required, new commands (and possibly replies) are required.  
      Do not make changes (or even expand) existing commands and replies.  Do not add new 
      replies to an existing command.
  3.  If you want different data in a reply from an existing command, then you need to 
      create a new command.  When a client submits a command, it expects the certain 
      replies to be in a particular format, and should not recieve something different.

Communications are broken up into two steps.  A 'command' which could otherwise be 
called a request, and a 'Reply'.   A command should always result in a single reply.   
If a command should result in a number of logical peices (such as retrieving a full 
map), then those peices would be wrapped in a container within the reply.  

All integers are to be transmitted using network-byte-order.
All strings are transmitted with a 4-byte int which indicates the length of the string, followed by
the string data itself.  Strings are not null-terminated.

All communications begin with a 12-byte header.
   ---------------------------------------------------------------------------------
   |   Short Int   | 2 bytes |  Command (or Reply) Identifier                      |
   |   Short Int   | 2 bytes |  Command being replied to (0 if not a reply)        |
   |   Integer     | 4 bytes |  User specified ID                                  |
   |   Integer     | 4 bytes |  Length of the data following this header (if any)  |
   ---------------------------------------------------------------------------------

All commands require a reply.  A reply takes the same format as a command, and has the same
12-byte header.  A command can generate different replies as needed.  A single 'command' will always 
return a single 'reply', although it may trigger further commands to come.  The reply will include 
a param that indicates the commandID that it is replying to.

The commands (and replies, indicated by *) are:
* 1     ack
* 2     fail
* 3     failinfo
* 4     tryelsewhere
* 9     unknown
  10    hello
  11    capabilities
  15    shuttingdown
  20    goodbye
  30    ping
  50    serverhello
  100   server_info
  120   hashmask
  200   req_loadlevel
* 210   loadlevels
  300   accept_bucket
* 305   cant_accept_bucket
* 310   accepting_bucket
  320   control_bucket
* 330   control_bucket_complete
  340   finalise_migration
* 345   migration_complete
* 346   migration_failed
  350   release_bucket
  1000  lock
  1010  unlock
  2000  set_int
  2010  set_long
  2020  set_string
  2100  get_int
  2110  get_long
  2120  get_string
  2200  get_type
  3000  sync_int
  3010  sync_long
  3020  sync_string
  3100  sync_name
  3101  sync_name_int
  

Note: To promote performance on the server, CommandID's less than 1000 do not require access to the
      clustered data.  CommandID's over 1000 internally require pipeline locks and need to be done
      in sequence.  The sub-1000 commands do not, and can be handled without going through the more
      expensive processing pipeline.




DATA PRIMITIVES

Different kinds of data can be stored in the cluster.  Several primitives are handled directly.  
In the event that these primitives are not enough, anything can be stored as a binary blob, which 
can be any kind of serialized object.  If you serialize using a portable object notation (such as 
POF, JSON, etc), you can put whatever complex objects that you want in there.

Hint:
    These data types are also used for parameter passing in network operations.
    

	+---------+------------+---------------------------------------------------------------------------+
	| Type    | Bytes      | Details                                                                   |
	+---------+------------+---------------------------------------------------------------------------+
	| Short   |  2         | A 16-bit integer, only used in command parameters.  Not a storable type.  |
	| Integer |  4         | A regular (32-bit) integer, signed.                                       |
	| Long    |  8         | A long (64-bit) integer, signed.                                          |
	| String  |  4 + data  | A variable length string. Integer is the length, followed by the data.    |
	+---------+------------+---------------------------------------------------------------------------+







MESSAGE STRUCTURES.

Note that some messages are commands, and some are replies.


-----------------------------------------------------------------------
ack (1)

General acknowlegement.  Used when no data is returned.

Type of message:
  Reply

Conditions of use:
  Sent from either client or server. 

Payload:
  none



-----------------------------------------------------------------------
fail (2)

General failure reply.  Used when no data is returned.

Type of message:
  Reply

Conditions of use:
  Sent from either client or server. 

Payload:
  none


-----------------------------------------------------------------------
failinfo (3)

General failure reply, to indicate that something failed, but this time return an error code and a
descriptive string.

Type of message:
  Reply

Conditions of use:
  Sent from either client or server. 

Payload:
  integer - error code.  
  string  - descriptive string of the failure.


-----------------------------------------------------------------------
tryelsewhere (4)

This reply is returned when the command was not successful because the server is not responsible
for the data requested. This can be because the server is leaving the cluster, or because the data
has moved around and is now on a different node.
 
It contains the information of a different server to try.

Type of message:
  Reply

Conditions of use:
  Sent from server to client. 

Payload:
  string - server to use

In response of:
  hello(10), if the server is shutting down, or not accepting client connections.



-----------------------------------------------------------------------
unknown (9)

This reply is returned when the command was not known on the server.  If the 
client is using a newer protocol that has newer commands, and it sends one to a 
server that doesn't understand it, the server will send this reply.  The client 
library will need to be smart enough to handle these capabilities correctly.  

This is only to be used as a reply.  There should be no such thing as a 'reply' 
that is not known.

Type of message:
  Reply

Conditions of use:
  Sent from server to client. 
  Sent from server to server. 
  Sent from client to server. 

Payload:
  short int - command that was attempted.

In response of:
  any command that it doesn't recognise.






-----------------------------------------------------------------------
hello (10)

This command is used by clients when they connect to a node. 
It does not contain any additional information, so it remains merely a header.
Calling a 'hello' will also result in 'serverlist' and 'hashmasks' information to follow as
seperate commands to the client.

Type of message:
  Command

Conditions of use:
  Sent from client to server. 

Payload:
  none

Replies:
  ack(1), on success.
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.




-----------------------------------------------------------------------
capabilities (11)

This command is used by clients and servers to ensure that the other end knows certain 
commands.  By providing the commandID, the server will respond with an 'ack', or an 'unknown' 
depending on if it knows it or not.   This can be used to avoid using certain commands 
the server doesn't know how to handle.


Type of message:
  Command

Conditions of use:
  Sent from client to server. 
  Sent from server to client.
  Sent from server to server.

Payload:
  short int - command

Replies:
  ack(1), if the command is accepted.
  fail(2), if the command is not known.



-----------------------------------------------------------------------
shutting down (15)

This command is used by server to tell other nodes that it is shutting down. 

It does not contain any additional information, so it remains merely a header.
When an ack(1) is received.

When a node receives this command from another node, it will mark that node as shutting down and 
will not attempt to move buckets to it, will remove that node as a backup to any other buckets.  It 
will also mark the node to not try and connect to it for a while.

Type of message:
  Command

Conditions of use:
  Sent from server to server.

Payload:
  none

Replies:
  ack(1), there is no failure condition that will mean anything.





-----------------------------------------------------------------------
goodbye (20)

This command is used by servers or clients to indicate that the connection is about to be
dropped. 

It does not contain any additional information, so it remains merely a header.
When an ack(1) is received, the connection can be closed.
If this is sent from a client, it will cause all registered events for this client to be cleared,
buffers to be reduced, and so on.  If the client sends a goodbye and then changes its mind, its
capabilities will be diminished, and the server may drop the connection anyway.
If this is sent from a server to a client, it will attempt to wait for an ack(1) from the client,
but if the client takes too long to respond, it will drop the connection anyway.
If this is sent from a server to a server, then certain synchronisations should already be in
place, but any that are outstanding will need to be resolved.

Type of message:
  Command

Conditions of use:
  Sent from client to server. 
  Sent from server to client.
  Sent from server to server.

Payload:
  none

Replies:
  ack(1), there is no failure condition that will mean anything.





-----------------------------------------------------------------------
ping(30)

This command is used to ensure that the server node is responding.  The client can send it
periodically if it wants, and the servers will send it to each other from time to time.


Type of message:
  Command

Conditions of use:
  Sent from client to server. 
  Sent from server to server.

Payload:
  none

Replies:
  ack(1), there is no failure condition that will mean anything.





-----------------------------------------------------------------------
serverhello(50)

This command is used by a server when it is connecting to another server.  It will include the
connection string so that the cluster can publish it to clients and other servers. 

Type of message:
  Command

Conditions of use:
  Sent from server to server.

Payload:
  string - connect info (normally in the form "IP:port", but can be any resolvable standard format)

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.




-----------------------------------------------------------------------
server_info(100)

Sends information about a server that is in the cluster to another node or client.  Normally is sent 
when a client or node connects, and needs a list of all the server nodes in the cluster.  The client 
should attempt to connect to each server that it knows about.

Type of message:
  Command

Conditions of use:
  Sent from server to server.
  Sent from server to cient.

Payload:
  string - connect info (normally in the form "IP:port", but can be any resolvable standard format)

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.





-----------------------------------------------------------------------
hashmask(120)

Sends an updated hashmask.

Type of message:
  Command

Conditions of use:
  Sent from server to server.
  Sent from server to client.

Payload:
  long - mask
  long - hash
  integer - instance count (-1 = not hosted, 0 = primary, 1 or more = backup).

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.






-----------------------------------------------------------------------
req_loadlevels(200)

Requests a server for its loadlevels.

Type of message:
  Command

Conditions of use:
  Sent from server to server.
  
Payload:
  none

Replies:
  loadlevels(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.






-----------------------------------------------------------------------
loadlevels(210)

Reply with the nodes current load levels.  This is used to determine if the data in the cluster 
needs to be balanced.

Type of message:
  Reply

Conditions of use:
  Sent from server to server.

Payload:
  integer - primary buckets
  integer - backup buckets
  integer - transfer states (0 = not currently transferring a bucket, 1 = currently transferring a bucket).








-----------------------------------------------------------------------
accept_bucket(300)

Tells a node start accepting data for a hash.

Type of message:
  Command

Conditions of use:
  Sent from server to server.
  
Payload:
  long - mask
  long - hash (bucket)

Replies:
  cant_accept_bucket(305)
  accepting_bucket(310)











-----------------------------------------------------------------------
cant_accept_bucket(305)

Indicates that the node cant accept the bucket.  Doesn't need to give a reason, but it could be because hte node already has that bucket in some way, or it is currently in the processing of transferring another bucket.

Type of message:
  Reply

Conditions of use:
  Sent from server to server.
  
Payload:
  long - mask
  long - hash (bucket)












-----------------------------------------------------------------------
accepting_bucket(310)

Indicates that the node is now accepting the transfer of that bucket.

Type of message:
  Reply

Conditions of use:
  Sent from server to server.
  
Payload:
  long - mask
  long - hash (bucket)














-----------------------------------------------------------------------
control_bucket(320)

Used by a node that is switching control with the other node.  The level indicates what the target 
should be after this completes.  So if level is 0, then the target must currently be level 1.  If 
the level is 1, then the target must currently be level 0.

Type of message:
  Command

Payload:
  long - mask
  long - hash (bucket)
  integer - level


-----------------------------------------------------------------------
control_bucket_complete (330)

Indicates that the process of transferring control of a bucket (either primary or secondary) has 
completed.

Type of message:
  Reply

Payload:
  long - mask
  long - hash (bucket)

-----------------------------------------------------------------------
control_bucket_failed (335)

The process for completing the control of a bucket failed.  This could be due to invalid data, or a 
bucket split within the cluster.  THe originating server should clear out the data involved in the 
migration and allow loadlevels to initiate the process again.

Type of message:
  Reply

Payload:
  long - mask
  long - hash (bucket)
  

-----------------------------------------------------------------------
finalise_migration (340)

Used by a node that has migrated a bucket to another server.  When all the data has been migrated, 
this command will tell the other node that all data is migrated, and it is now either a primary or a 
backup, and the alternate node is X.

Type of message:
  Command

Payload:
  long - mask
  long - hash (bucket)
  integer - level
  string  - alternate data node (source or backup depending on level)



-----------------------------------------------------------------------
migration_complete (345)

Indicates that the process of transferring control of a bucket (either primary or secondary) has completed.

Type of message:
  Reply

Payload:
  long - mask
  long - hash (bucket)

  
-----------------------------------------------------------------------
migration_failed (346)

The process for completing the migration of a bucket failed.  This could be due to invalid data, or 
a bucket split within the cluster.  THe originating server should clear out the data involved in the 
migration and allow loadlevels to initiate the process again.

Type of message:
  Reply

Payload:
  long - mask
  long - hash (bucket)
  


-----------------------------------------------------------------------
release_bucket (350)

Server node telling another node to release control of a bucket.  This is only valid if the node that sent it is the 

Type of message:
  Command

Payload:
  long - mask
  long - hash (bucket)



-----------------------------------------------------------------------
promote_bucket(400)

Used by the master of a bucket, to promote a backup copy to be the master.  

Payload:
  long - mask
  long - hash (bucket)

-----------------------------------------------------------------------
remove_bucket(420)

Used by the master of a bucket, to tell a backup copy that it is no longer needed and can be 
destroyed.  The backup copy should not have any subscriptions or anything, so it doesn't need any 
special information about where the master bucket is, although it should already know that from the 
HASHMASK updates.
erin@token.com.au

Payload:
  long - mask
  long - hash (bucket)


-----------------------------------------------------------------------
set_int(2000)

Set an integer (32-bit) key/value, overwriting if it exists.

Payload:
  long    - map hash (0 for non-map items)
  long    - key hash
  integer - expires (in seconds from now, 0 means it never expires)
  long    - value (to be stored).
  string  - name

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.



-----------------------------------------------------------------------
  2020  set_string   set a variable length string key/value.
-----------------------------------------------------------------------
get_int(2100)

get an integer (64-bit) key/value pair.

Payload:
  long - map hash (0 for non-map items)
  long - key hash

Replies:
  data_int(2105), return the integer data.
  nack(), if that data doesnt exist or has been expired.
  tryelsewhere(4), if the bucket is being served by a different server.
  

-----------------------------------------------------------------------
data_int(2105)

The integer (64-bit) result from a key lookup

Reply.

Payload:
  long - map hash (0 for non-map items)
  long - key hash
  long - value

  

-----------------------------------------------------------------------
  2120  get_string   get a variable length string key/value.
-----------------------------------------------------------------------
  2200  get_type     get the type of the data.


-----------------------------------------------------------------------
sync_int(3000) [COMMAND]

Migrate an integer (32-bit) key/value, overwriting if it exists.

Payload:
  long - map hash (0 for non-map items)
  long - key hash
  integer - expires (in seconds from now, 0 means it never expires)
  long - value (to be stored).

Replies:
  sync_ack(3005)
  sync_fail(3006)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.

-----------------------------------------------------------------------
sync_ack(3005) [REPLY]

Acknowledge a sync operation, providing the information to indicate which sync operation was successful.

Payload:
  long - map hash (0 for non-map items)
  long - key hash

-----------------------------------------------------------------------
sync_fail(3006) [REPLY]

A sync operation failed.  This could be for any number of reasons.  Such as the server going 
offline, or the buckets have been split and this bucket no longer is valid.

Payload:
  long - map hash (0 for non-map items)
  long - key hash



-----------------------------------------------------------------------
  3020  sync_string

Migrate an string key/value, overwriting if it exists.

Payload:
  long - map hash (0 for non-map items)
  long - key hash
  integer - expires (in seconds from now, 0 means it never expires)
  string - value (to be stored).

Replies:
  sync_ack(3005)
  sync_fail(3006)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.

-----------------------------------------------------------------------
sync_name(3100)

Each hash has a readable name associated with it, provided by the client.  We dont need to include 
it with every single update, but for new items we will need to provide it.

Payload:
  long - key hash
  string  - name

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.


-----------------------------------------------------------------------
sync_name_int(3101)

Each hash has either a readable name or an integer associated with it, provided by the client.  We 
dont need to include it with every single update, but for new items we will need to provide it.

Payload:
  long - key hash
  long - user index

Replies:
  ack(1)
  tryelsewhere(4), if the server is shutting down, or not accepting client connections.


-----------------------------------------------------------------------
sync_name_ack(3105) [REPLY]

Acknowledge a sync name operation, providing the information to indicate which sync operation was successful.

Payload:
  long - key hash

-----------------------------------------------------------------------
sync_name_fail(3106) [REPLY]

A sync operation failed.  This could be for any number of reasons.  Such as the server going 
offline, or the buckets have been split and this bucket no longer is valid.

Payload:
  long - key hash



-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------




