Although I've mentioned MD5 a few times in the design, I was never really set on MD5 exactly, as I wanted to choose one 
that had a nice mix of raw performance and low rate of collision.

MD5 would functionally work, but its not the fastest hashing algorithm.
A lot of hashing algorithms are designed for cryptography which has additional requirements and restrictions.

I've found several, such as MurmurHash, FNV Hash, and something called Jenkins.

Here are some links.
http://www.burtleburtle.net/bob/hash/doobs.html
http://www.burtleburtle.net/bob/c/lookup3.c
http://code.google.com/p/smhasher/
http://www.isthe.com/chongo/tech/comp/fnv/index.html
http://www.getopt.org/utils/build/api/org/getopt/util/hash/FNV1.html



We need to pick a hashing algorithm that would be fast to implement in various languages such as C, Java, Perl, C#, 
etc..  NOTE that a fast implementation in C might be usable in a lot of other languages.  Java can utilise a C version.





FNV Hash in java?
public class FnvHash {

private static final int kFNVOffset = (int) 2166136261l;
private static final int kFNVPrime = 16777619;

public static long fnvHashCode(final String str) {
int hash = kFNVOffset;

for (int i = 0; i < str.length(); i++) {
hash ^= (0x0000ffff & (int)str.charAt(i));
hash *= kFNVPrime;
}

return 0x00000000ffffffffl & (long) hash;
}

}
