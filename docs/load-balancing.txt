
OpenCluster Load Balancing.

In order to keep the cluster functioning smoothly across the entire range of nodes, it needs to be able to 
balance the data (and presumably the load) amongst the different nodes.

  NOTE:  It is assumed that all the nodes in the cluster have equivilant processing and storage 
         capabilities.  If it is determined that there is a need to specify that some nodes in the 
         cluster are more capable than others, and give them more load, we can evaluate this 
         functionality, but it may be easier to have a cluster of similar spec machines.

         Technically, the specifications of the server would not be that fantastic anyway, so a 
         cluster of various machines from low-end to high-end should assume that the lowest spec 
         machine is the minimum required for the amount of functionality required.


When the first node in the cluster starts up, it becomes responsible for all the buckets, and there 
are no backups.   If there is only one node in the cluster, and that node goes offline, then the 
cluster is gone also.

A single node can still function just as well as a cluster, and from a client perspective would 
provide full functionality (aside from replication of data).

When a second node joins the cluster, the first one will give half of its buckets to the secondary 
server to be primary, and will tell the second node to also be a backup of the other buckets.  This 
results in both servers having a copy of all the buckets in the cluster.

  example of a single server...

  +--------------------------+
  |                          |
  |  Server 1                |
  |    Bucket #1  - primary  |
  |    Bucket #2  - primary  |
  |    Bucket #3  - primary  |
  |    Bucket #4  - primary  |
  |    Bucket #5  - primary  |
  |    Bucket #6  - primary  |
  |    Bucket #7  - primary  |
  |    Bucket #8  - primary  |
  |    Bucket #9  - primary  |
  |    Bucket #10 - primary  |
  |    Bucket #11 - primary  |
  |    Bucket #12 - primary  |
  |    Bucket #13 - primary  |
  |    Bucket #14 - primary  |
  |    Bucket #15 - primary  |
  |    Bucket #16 - primary  |
  |                          |
  +--------------------------+

  then when a second node joins the first.. the buckets are split over the two servers 


  +--------------------------+  +--------------------------+
  |                          |  |                          |
  |  Server A                |  |  Server B                |
  |    Bucket #1  - primary  |  |    Bucket #1  - backup   |
  |    Bucket #2  - backup   |  |    Bucket #2  - primary  |
  |    Bucket #3  - primary  |  |    Bucket #3  - backup   |
  |    Bucket #4  - backup   |  |    Bucket #4  - primary  |
  |    Bucket #5  - primary  |  |    Bucket #5  - backup   |
  |    Bucket #6  - backup   |  |    Bucket #6  - primary  |
  |    Bucket #7  - primary  |  |    Bucket #7  - backup   |
  |    Bucket #8  - backup   |  |    Bucket #8  - primary  |
  |    Bucket #9  - primary  |  |    Bucket #9  - backup   |
  |    Bucket #10 - backup   |  |    Bucket #10 - primary  |
  |    Bucket #11 - primary  |  |    Bucket #11 - backup   |
  |    Bucket #12 - backup   |  |    Bucket #12 - primary  |
  |    Bucket #13 - primary  |  |    Bucket #13 - backup   |
  |    Bucket #14 - backup   |  |    Bucket #14 - primary  |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |
  |    Bucket #16 - backup   |  |    Bucket #16 - primary  |
  |                          |  |                          |
  +--------------------------+  +--------------------------+

      NOTE: although this diagram shows a pattern between primary 
            and backup balancing, the server would actually 
            transfer the buckets in semi-random order.

Also note that, if the backup buckets are kept in sync with the primary buckets, then a server can 
go offline quickly and orderly by simply telling the servers containing the backup buckets, that 
they are now primary.

The way the bucket migration works, is that when a node joins another server, it establishes an 
event on that server that fires every so often.  

So lets go back to the state of things when Server B joined the cluster that was previously only the 
single Server A.


  +--------------------------+  +--------------------------+
  |                          |  |                          |
  |  Server A                |  |  Server B                |
  |    Bucket #1  - primary  |  |    Bucket #1  -          |
  |    Bucket #2  - primary  |  |    Bucket #2  -          |
  |    Bucket #3  - primary  |  |    Bucket #3  -          |
  |    Bucket #4  - primary  |  |    Bucket #4  -          |
  |    Bucket #5  - primary  |  |    Bucket #5  -          |
  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - primary  |  |    Bucket #9  -          |
  |    Bucket #10 - primary  |  |    Bucket #10 -          |
  |    Bucket #11 - primary  |  |    Bucket #11 -          |
  |    Bucket #12 - primary  |  |    Bucket #12 -          |
  |    Bucket #13 - primary  |  |    Bucket #13 -          |
  |    Bucket #14 - primary  |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 -          |
  |    Bucket #16 - primary  |  |    Bucket #16 -          |
  |                          |  |                          |
  +--------------------------+  +--------------------------+

At this point, both Server A and Server B would have a LoadBalancing event fire every so often 
(more often when the cluster is unbalanced, less often when things are balanced).  This event will 
query the other node, saying "How much load do you have?" and the node will respond with something 
like "12 primary buckets, 4 secondary buckets" (as an example).  The node will compare that reply 
with what it currently has and will decide if it wants to push a bucket to the other server or not.

  NOTE: New nodes are not able to request buckets.  They just receive them when other nodes 
        determine that it should be given one.  This could be a result of balancing, or it could be 
        a result of that other server being shutdown and it must send the buckets somewhere.

So, Server A sends a request asking Server B for its load levels, and Server B, at this point, Sends 
back that it is not currently holding any primary or secondary buckets.  Server A will then look at 
how many Primary and Secondary buckets it has, determins that it has more buckets than B, and so 
decides to send send one to the other server.

  NOTE: If a node receives a request to take over a bucket, it should do its best to accomodate.  It 
        may be that the other server is shutting down and is offloading buckets.  So the receiving 
        server should always accept new buckets, UNLESS it is already in the process of receiving 
        another bucket from some other node.  A node can only receive one bucket at a time.

Servers nodes can ONLY send primary buckets to other servers and marks them as backup buckets.  
Server nodes cannot transfer a backup bucket to another node.  The actual master of the bucket is 
the only one that can determine where it goes.

Server A sends a message to B saying "I'm going to be giving you Bucket #1, be prepared for it".  
At this point Server B would normally respond with an "OK, start sending bucket #1", but if it is 
already in the process of being given a bucket from another node, it can say "Sorry, Bucket transfer 
already in progress".  In this case though, there is only the two nodes, so it will be responding 
positively.  

Server A then starts sending all the data contained in Bucket #1.  It will send it item by item, 
trying not to overload either server with a sudden rush of traffic, because while this 
synchronisation is going on, it will also need to service requests from clients, including requests 
for that bucket being transferred.

  NOTE: Server A is still responsible for that bucket while it is being transferred and will still 
        be updating the data and responding to requests.   Each bucket will maintain a list of items 
        that have been modified.  The sync process will initially fill that list with all the items, 
        and remove them as it sync's them.  When updates occur, that item is just re-added to the 
        list.

While the sync is going on, it will not trigger any more LoadBalancing events (or, if it does, they 
will be ignored).  In other words, it will only be attempting to balance one bucket at a time.

When Server A has managed to send ALL the items belonging to Bucket #1 to Server B, the following 
things happen:
  1.  Server A tells Server B "Synchronisation is complete, you are now a backup for Bucket #1"
  2.  If Server A previously had a different backup node for that bucket, then it will send a 
      message to that node telling it to destroy its copy of the bucket.  In this case, there was no 
      backup version though.
  3.  Server A marks Server B as a backup of that bucket, and will continue sending sync info to 
      that node when contents of the bucket is changed.
  4.  Server B sends a message to all its connected clients (and nodes) saying that it is a backup 
      provider of Bucket #1.
  5.  Server A and B will start doing LoadBalancing events again.


Now we have:

  +--------------------------+  +--------------------------+
  |                          |  |                          |
  |  Server A                |  |  Server B                |
  |    Bucket #1  - primary  |  |    Bucket #1  - backup   |
  |    Bucket #2  - primary  |  |    Bucket #2  -          |
  |    Bucket #3  - primary  |  |    Bucket #3  -          |
  |    Bucket #4  - primary  |  |    Bucket #4  -          |
  |    Bucket #5  - primary  |  |    Bucket #5  -          |
  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - primary  |  |    Bucket #9  -          |
  |    Bucket #10 - primary  |  |    Bucket #10 -          |
  |    Bucket #11 - primary  |  |    Bucket #11 -          |
  |    Bucket #12 - primary  |  |    Bucket #12 -          |
  |    Bucket #13 - primary  |  |    Bucket #13 -          |
  |    Bucket #14 - primary  |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 -          |
  |    Bucket #16 - primary  |  |    Bucket #16 -          |
  |                          |  |                          |
  +--------------------------+  +--------------------------+


So now that the sync and migration of the bucket has completed, regular LoadBalancing events will 
continue to be fired.  

Server B will ask Server A for its LoadLevel's but will see that A has more buckets, and therefore 
B should not send any to A.  Remember, a node cannot request buckets, it can only give them away.

Server A, when asking Server B for LoadLevels will now be told, "I have 0 primary and 1 secondary 
buckets".  A sees that its total number of buckets exceeds B's, so decides to send it another 
bucket.

Server A can only choose from Primary buckets it has, and the first primary bucket it has in the 
list is now #2.    

At the begining of this process, we can assume:

  +--------------------------+  +--------------------------+
  |                          |  |                          |
  |  Server A                |  |  Server B                |
  |    Bucket #1  - primary  |  |    Bucket #1  - backup   |
  |    Bucket #2  - primary  |  |    Bucket #2  - backup   |
  |    Bucket #3  - primary  |  |    Bucket #3  -          |
  |    Bucket #4  - primary  |  |    Bucket #4  -          |
  |    Bucket #5  - primary  |  |    Bucket #5  -          |
  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - primary  |  |    Bucket #9  -          |
  |    Bucket #10 - primary  |  |    Bucket #10 -          |
  |    Bucket #11 - primary  |  |    Bucket #11 -          |
  |    Bucket #12 - primary  |  |    Bucket #12 -          |
  |    Bucket #13 - primary  |  |    Bucket #13 -          |
  |    Bucket #14 - primary  |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 -          |
  |    Bucket #16 - backup   |  |    Bucket #16 -          |
  |                          |  |                          |
  +--------------------------+  +--------------------------+

The same process will continue, until the number of buckets on the two servers are balanced.  
In the end, we could end up with something like:

  +--------------------------+  +--------------------------+
  |                          |  |                          |
  |  Server A                |  |  Server B                |
  |    Bucket #1  - primary  |  |    Bucket #1  - backup   |
  |    Bucket #2  - primary  |  |    Bucket #2  - backup   |
  |    Bucket #3  - primary  |  |    Bucket #3  - backup   |
  |    Bucket #4  - primary  |  |    Bucket #4  - backup   |
  |    Bucket #5  - primary  |  |    Bucket #5  - backup   |
  |    Bucket #6  - primary  |  |    Bucket #6  - backup   |
  |    Bucket #7  - primary  |  |    Bucket #7  - backup   |
  |    Bucket #8  - primary  |  |    Bucket #8  - backup   |
  |    Bucket #9  - primary  |  |    Bucket #9  - backup   |
  |    Bucket #10 - primary  |  |    Bucket #10 - backup   |
  |    Bucket #11 - primary  |  |    Bucket #11 - backup   |
  |    Bucket #12 - primary  |  |    Bucket #12 - backup   |
  |    Bucket #13 - primary  |  |    Bucket #13 - backup   |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |
  |                          |  |                          |
  +--------------------------+  +--------------------------+

This is not yet an ideal situation because currently all the primary buckets are on one server, and 
all the backup buckets are on another.  We need them to be evenly mixed.

The LoadBalancing events will continue to be fired from each one.  B will not be able to really do 
anything because it does not have any primary buckets.  It has very little control of the backup 
buckets that it has.

The LoadBalancing event on A will be more productive though, because B will report back that it has 
0 primaries and 16 backups.  When A sees that B has more backups than it has primaries, and a change
wont reverse the ratio (we dont want to go from more secondaries, to more primaries), it will decide 
to send one of its primary buckets to B.  Note that B already has the complete bucket, so all it is 
doing is flipping the responsibility.  It will generally flip the first bucket that it finds, that 
is a primary on A, and a secondary on B.  In this case, Bucket #1.

So we end up with:

  +--------------------------+  +--------------------------+
  |  Server A                |  |  Server B                |
  |    Bucket #1  - backup   |  |    Bucket #1  - primary  |
  |    Bucket #2  - primary  |  |    Bucket #2  - backup   |
  |    Bucket #3  - primary  |  |    Bucket #3  - backup   |
  |    Bucket #4  - primary  |  |    Bucket #4  - backup   |
  |    Bucket #5  - primary  |  |    Bucket #5  - backup   |
  |    Bucket #6  - primary  |  |    Bucket #6  - backup   |
  |    Bucket #7  - primary  |  |    Bucket #7  - backup   |
  |    Bucket #8  - primary  |  |    Bucket #8  - backup   |
  |    Bucket #9  - primary  |  |    Bucket #9  - backup   |
  |    Bucket #10 - primary  |  |    Bucket #10 - backup   |
  |    Bucket #11 - primary  |  |    Bucket #11 - backup   |
  |    Bucket #12 - primary  |  |    Bucket #12 - backup   |
  |    Bucket #13 - primary  |  |    Bucket #13 - backup   |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |
  +--------------------------+  +--------------------------+

This same process would continue until we end up with a balanced cluster, which would look something 
like:

  +--------------------------+  +--------------------------+
  |  Server A                |  |  Server B                |
  |    Bucket #1  - backup   |  |    Bucket #1  - primary  |
  |    Bucket #2  - backup   |  |    Bucket #2  - primary  |
  |    Bucket #3  - backup   |  |    Bucket #3  - primary  |
  |    Bucket #4  - backup   |  |    Bucket #4  - primary  |
  |    Bucket #5  - backup   |  |    Bucket #5  - primary  |
  |    Bucket #6  - backup   |  |    Bucket #6  - primary  |
  |    Bucket #7  - backup   |  |    Bucket #7  - primary  |
  |    Bucket #8  - backup   |  |    Bucket #8  - primary  |
  |    Bucket #9  - primary  |  |    Bucket #9  - backup   |
  |    Bucket #10 - primary  |  |    Bucket #10 - backup   |
  |    Bucket #11 - primary  |  |    Bucket #11 - backup   |
  |    Bucket #12 - primary  |  |    Bucket #12 - backup   |
  |    Bucket #13 - primary  |  |    Bucket #13 - backup   |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |
  +--------------------------+  +--------------------------+


This can get further complicated, when a third server joins the cluster.

  +--------------------------+  +--------------------------+  +--------------------------+
  |  Server A                |  |  Server B                |  |  Server C                |
  |    Bucket #1  - backup   |  |    Bucket #1  - primary  |  |    Bucket #1  -          |
  |    Bucket #2  - backup   |  |    Bucket #2  - primary  |  |    Bucket #2  -          |
  |    Bucket #3  - backup   |  |    Bucket #3  - primary  |  |    Bucket #3  -          |
  |    Bucket #4  - backup   |  |    Bucket #4  - primary  |  |    Bucket #4  -          |
  |    Bucket #5  - backup   |  |    Bucket #5  - primary  |  |    Bucket #5  -          |
  |    Bucket #6  - backup   |  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - backup   |  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - backup   |  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - primary  |  |    Bucket #9  - backup   |  |    Bucket #9  -          |
  |    Bucket #10 - primary  |  |    Bucket #10 - backup   |  |    Bucket #10 -          |
  |    Bucket #11 - primary  |  |    Bucket #11 - backup   |  |    Bucket #11 -          |
  |    Bucket #12 - primary  |  |    Bucket #12 - backup   |  |    Bucket #12 -          |
  |    Bucket #13 - primary  |  |    Bucket #13 - backup   |  |    Bucket #13 -          |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |  |    Bucket #15 -          |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |  |    Bucket #16 -          |
  +--------------------------+  +--------------------------+  +--------------------------+

The first server to fire a LoadBalancing event against Server C will see that it has less buckets 
than the other, and will start sending buckets to it.   Remember that only one Bucket can be 
transferred to the node at a time.

One extra thing to note here, is that by default the servers will be setup to only keep one backup 
of each bucket.  So if a primary bucket is being migrated to Server C, then the current backup node 
will be told that it can release the bucket (after the synchronisation is complete).

We can use Bucket #1 as an example.  Here we have Server A being the backup, and B being the 
primary.  If B is wanting to move that bucket to Server C, it would start the process as in the 
previous examples.   It will start sending the data to C, and when finished, C will become the 
backup, B will continue to be the primary, and A will be told that it can drop the bucket entirely.

So we end up with:

  +--------------------------+  +--------------------------+  +--------------------------+
  |  Server A                |  |  Server B                |  |  Server C                |
  |    Bucket #1  -          |  |    Bucket #1  - primary  |  |    Bucket #1  - backup   |
  |    Bucket #2  - backup   |  |    Bucket #2  - primary  |  |    Bucket #2  -          |
  |    Bucket #3  - backup   |  |    Bucket #3  - primary  |  |    Bucket #3  -          |
  |    Bucket #4  - backup   |  |    Bucket #4  - primary  |  |    Bucket #4  -          |
  |    Bucket #5  - backup   |  |    Bucket #5  - primary  |  |    Bucket #5  -          |
  |    Bucket #6  - backup   |  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - backup   |  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - backup   |  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - primary  |  |    Bucket #9  - backup   |  |    Bucket #9  -          |
  |    Bucket #10 - primary  |  |    Bucket #10 - backup   |  |    Bucket #10 -          |
  |    Bucket #11 - primary  |  |    Bucket #11 - backup   |  |    Bucket #11 -          |
  |    Bucket #12 - primary  |  |    Bucket #12 - backup   |  |    Bucket #12 -          |
  |    Bucket #13 - primary  |  |    Bucket #13 - backup   |  |    Bucket #13 -          |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |  |    Bucket #15 -          |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |  |    Bucket #16 -          |
  +--------------------------+  +--------------------------+  +--------------------------+

If by a quirk of fate, Server B happens to be rather busy, and A manages to send half its buckets 
to C, then it is still ok, because B will stop being a backup for some of the buckets.  So it 
should still end up being rather balanced.

This same scenario will scale up to many more nodes.

While migrating the buckets over the three servers, we would eventually end up with something 
similar to this incomplete migration (it is incomplete beacuse it is still unbalanced, but would 
eventually balance out):

So we continue sending backup buckets to Server C from the existing nodes, and we end up with this:

  +--------------------------+  +--------------------------+  +--------------------------+
  |  Server A                |  |  Server B                |  |  Server C                |
  |    Bucket #1  -          |  |    Bucket #1  - primary  |  |    Bucket #1  - backup   |
  |    Bucket #2  -          |  |    Bucket #2  - primary  |  |    Bucket #2  - backup   |
  |    Bucket #3  -          |  |    Bucket #3  - primary  |  |    Bucket #3  - backup   |
  |    Bucket #4  -          |  |    Bucket #4  - primary  |  |    Bucket #4  - backup   |
  |    Bucket #5  -          |  |    Bucket #5  - primary  |  |    Bucket #5  - backup   |
  |    Bucket #6  - backup   |  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - backup   |  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - backup   |  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - primary  |  |    Bucket #9  -          |  |    Bucket #9  - backup   |
  |    Bucket #10 - primary  |  |    Bucket #10 -          |  |    Bucket #10 - backup   |
  |    Bucket #11 - primary  |  |    Bucket #11 -          |  |    Bucket #11 - backup   |
  |    Bucket #12 - primary  |  |    Bucket #12 -          |  |    Bucket #12 - backup   |
  |    Bucket #13 - primary  |  |    Bucket #13 -          |  |    Bucket #13 - backup   |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |  |    Bucket #15 -          |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |  |    Bucket #16 -          |
  +--------------------------+  +--------------------------+  +--------------------------+
        8 + 3 = 11                     8 + 3 = 11                     0 + 10 = 10

Thats not completely balanced yet, because A and B have a lot of primaries and C has only backups.  
Now when LoadBalancing events are fired, instead of sending buckets, we must now promote some.

A gets a Load Level reply from C, and will see that the number of buckets is ok (we dont want to 
send more buckets if that means the target node will have more.  Only send if the target node will 
remain with less, or both are even).  So instead it looks at the ratio of backups to primaries.  In 
this case, C has more backups than it does primary, so it A will go through its list to find the 
first bucket where it is a primary, and the secondary is on C (in this case Bucket #9).  When it 
finds that, it will promote that bucket on C to be primary, and the bucket on A will become 
secondary.  This process should be instant.

And we end up with:

  +--------------------------+  +--------------------------+  +--------------------------+
  |  Server A                |  |  Server B                |  |  Server C                |
  |    Bucket #1  -          |  |    Bucket #1  - primary  |  |    Bucket #1  - backup   |
  |    Bucket #2  -          |  |    Bucket #2  - primary  |  |    Bucket #2  - backup   |
  |    Bucket #3  -          |  |    Bucket #3  - primary  |  |    Bucket #3  - backup   |
  |    Bucket #4  -          |  |    Bucket #4  - primary  |  |    Bucket #4  - backup   |
  |    Bucket #5  -          |  |    Bucket #5  - primary  |  |    Bucket #5  - backup   |
  |    Bucket #6  - backup   |  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - backup   |  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - backup   |  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - backup   |  |    Bucket #9  -          |  |    Bucket #9  - primary  |
  |    Bucket #10 - primary  |  |    Bucket #10 -          |  |    Bucket #10 - backup   |
  |    Bucket #11 - primary  |  |    Bucket #11 -          |  |    Bucket #11 - backup   |
  |    Bucket #12 - primary  |  |    Bucket #12 -          |  |    Bucket #12 - backup   |
  |    Bucket #13 - primary  |  |    Bucket #13 -          |  |    Bucket #13 - backup   |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |  |    Bucket #15 -          |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |  |    Bucket #16 -          |
  +--------------------------+  +--------------------------+  +--------------------------+
        7 + 4 = 11                     8 + 3 = 11                     1 + 9 = 10

This will keep going until we end up with a balance, and we have:

  +--------------------------+  +--------------------------+  +--------------------------+
  |  Server A                |  |  Server B                |  |  Server C                |
  |    Bucket #1  -          |  |    Bucket #1  - backup   |  |    Bucket #1  - primary  |
  |    Bucket #2  -          |  |    Bucket #2  - backup   |  |    Bucket #2  - primary  |
  |    Bucket #3  -          |  |    Bucket #3  - primary  |  |    Bucket #3  - backup   |
  |    Bucket #4  -          |  |    Bucket #4  - primary  |  |    Bucket #4  - backup   |
  |    Bucket #5  -          |  |    Bucket #5  - primary  |  |    Bucket #5  - backup   |
  |    Bucket #6  - backup   |  |    Bucket #6  - primary  |  |    Bucket #6  -          |
  |    Bucket #7  - backup   |  |    Bucket #7  - primary  |  |    Bucket #7  -          |
  |    Bucket #8  - backup   |  |    Bucket #8  - primary  |  |    Bucket #8  -          |
  |    Bucket #9  - backup   |  |    Bucket #9  -          |  |    Bucket #9  - primary  |
  |    Bucket #10 - backup   |  |    Bucket #10 -          |  |    Bucket #10 - primary  |
  |    Bucket #11 - backup   |  |    Bucket #11 -          |  |    Bucket #11 - primary  |
  |    Bucket #12 - primary  |  |    Bucket #12 -          |  |    Bucket #12 - backup   |
  |    Bucket #13 - primary  |  |    Bucket #13 -          |  |    Bucket #13 - backup   |
  |    Bucket #14 - primary  |  |    Bucket #14 - backup   |  |    Bucket #14 -          |
  |    Bucket #15 - primary  |  |    Bucket #15 - backup   |  |    Bucket #15 -          |
  |    Bucket #16 - primary  |  |    Bucket #16 - backup   |  |    Bucket #16 -          |
  +--------------------------+  +--------------------------+  +--------------------------+
        5 + 6 = 11                     6 + 5 = 11                     5 + 5 = 10

Now we have a completely balanced cluster, with an even mix of primary and secondary buckets on all 
three nodes.  The process will continue when other nodes join the cluster.

Things only get tricky when a server attempts to splits its buckets, while another server is sending 
a bucket to yet another server.  When that occurs, the transfer is stopped, and restarted, the data 
already sent discarded.  Then, rebalancing would continue with a new number of buckets.


This situation doesn't mean that there can be only a maximum of 16 nodes, because when a server gets 
to the point where it has only 4 buckets (total), it will split those 4 buckets into smaller 
buckets.  In the process of splitting and informing the other nodes of the changed hashmasks, that 
will trigger all the other nodes in the cluster to also split their own buckets.   It may take a few 
cycles for the splits to complete across the cluster, but during that time, all the hashes will 
still resolve to the same nodes, so nothing should be disturbed.   After the split, those 4 buckets 
on the server would now be 64 smaller buckets.  It can continue to load balance them in the exact 
same way as we did before with only 16 buckets.  Those original 16 buckets on the cluster, have now 
become 256 buckets (stored twice, so actually 512).

The same again can happen when there are even more nodes in the cluster.  It will split to have a 
total of 4096 primary buckets.


WHAT HAPPENS IF A SPLIT HAPPENS WHILE TRANSFERRING A BUCKET?

A split would occur if another node sends a HASHMASK command that has a new mask.  This will require 
the node to split its own buckets.  When this happens a migration in progress is no longer valid, so 
it will be cancelled.  The target of the migration will delete the contents that it has already 
received, and it would likely be receiving messages shortly telling requiring it to split also.

If a receiving node (of a migration) needs to split, then it will send a message to the source node 
telling it that it is cancelling the transfer.

Once the migration is cancelled, normal loadlevel activity will commence and the new buckets will 
start migrating out to servers with less load.



NODES LEAVING THE CLUSTER

So far this document has explained how a cluster grows, but it is just as important to shrink 
gracefully also.

The number of buckets wont reduce.  Once the buckets are split, they stay split.  But thats ok, 
because it doesnt really matter if there is 4096 buckets spread over only a few nodes.

When the cluster is generally in sync, there are normally two copies of each bucket.  If a server 
needs  to shutdown (gracefully), it should be able to quickly release the buckets it has, and the 
backup copies become primary.  That node would then try to find other nodes to create a backup 
bucket on.

If the nodes are badly out of sync when a shutdown is needed, it would need to wait until the sync 
is completed.




HANDLING A DEAD NODE

Handling the situation of a dead node is rather tricky, but important.

A heartbeat is sent between servers.  Also, a Bucket_SYNC heartbeat is sent from the primary to the 
backup bucket every second.  This is used to determine how current the bucket is.  Part of this SYNC 
command is the number of items that are currently pending synchronisation.  This is useful for the 
receiving server to know how complete the bucket transfer is.

If the Node with the backup bucket does not receive the SYNC heartbeat several times in a row, and 
has not received any other data from the server (its possible the server has been sending over 
capacity, and the heartbeats are still on the pipe), then the backup bucket will go into a PENDING 
mode.  It doesn't actively do anything, but it will set that flag.  If it does get data from that 
server, it will clear the flag and everything will go back to normal.   

The clients generally know the primary and backup servers for each bucket.  If a client is unable to 
get a responce within a certain timeout from the primary server, it will close the connection to the 
primary, and will ask the backup server for the data instead.   If the backup server is NOT in 
PENDING mode, then it will simply reply with a message saying "Not responsible for that bucket... 
try this other server instead".   But if it IS in that PENDING state, then it will assume that if it 
cant see the other server, and the clients cant see the other server, then the other server must be 
dead.  It will disconnect any remaining connection to the other server, and promote its own copy of 
the bucket to primary.  It will also start looking for other servers to transfer backup buckets to.

  NOTE: If two nodes are comparing load levels, and they have the same number of buckets, a node can 
        still send a bucket to another node if there is no backup bucket for that bucket.   This is 
        only likely to occur if several nodes goe offline and leaves the cluster in a curi, with intact buckets, it will find that those buckets already exist 
on the cluster, and it will need to delete them.  The tricky part is determining which server is 
correct, and which server is not.   



PROBLEMS NOT YET DEALT WITH.

  1.  What happens if a server goes offline suddenly, and it was the only node in the cluster 
      holding a certain bucket (because the initial sync was still occuring).

  2.  What happens if two nodes go down at the same time (maybe a data center failure), and those 
      two servers were the only ones on the cluster responsible for a couple of buckets.  What will 
      trigger the other nodes to re-create those missing buckets?

  3.  When a network error happens and neither node is able to determine which one is responsible 
      for a bucket, and has had local clients updating both of them.  They both have new data.  How 
      can those broken buckets be merged?


CONTINUING THE CLUSTER WITH MORE NODES

Where we left off.

B = Backup bucket (or secondary)
P = Primary bucket

 +---------+ +---------+ +---------+
 | NODE-A  | | NODE-B  | | NODE-C  |
 | #1  -   | | #1  - B | | #1  - P |
 | #2  -   | | #2  - B | | #2  - P |
 | #3  -   | | #3  - P | | #3  - B |
 | #4  -   | | #4  - P | | #4  - B |
 | #5  -   | | #5  - P | | #5  - B |
 | #6  - B | | #6  - P | | #6  -   |
 | #7  - B | | #7  - P | | #7  -   |
 | #8  - B | | #8  - P | | #8  -   |
 | #9  - B | | #9  -   | | #9  - P |
 | #10 - B | | #10 -   | | #10 - P |
 | #11 - B | | #11 -   | | #11 - P |
 | #12 - P | | #12 -   | | #12 - B |
 | #13 - P | | #13 -   | | #13 - B |
 | #14 - P | | #14 - B | | #14 -   |
 | #15 - P | | #15 - B | | #15 -   |
 | #16 - P | | #16 - B | | #16 -   |
 +---------+ +---------+ +---------+
   5+6=11      6+5=11      5+5=10

So now another node joins the cluster, initially with no buckets.

 +---------+ +---------+ +---------+ +---------+
 | NODE-A  | | NODE-B  | | NODE-C  | | NODE-D  |
 | #1  -   | | #1  - B | | #1  - P | | #1  -   |
 | #2  -   | | #2  - B | | #2  - P | | #2  -   |
 | #3  -   | | #3  - P | | #3  - B | | #3  -   |
 | #4  -   | | #4  - P | | #4  - B | | #4  -   |
 | #5  -   | | #5  - P | | #5  - B | | #5  -   |
 | #6  - B | | #6  - P | | #6  -   | | #6  -   |
 | #7  - B | | #7  - P | | #7  -   | | #7  -   |
 | #8  - B | | #8  - P | | #8  -   | | #8  -   |
 | #9  - B | | #9  -   | | #9  - P | | #9  -   |
 | #10 - B | | #10 -   | | #10 - P | | #10 -   |
 | #11 - B | | #11 -   | | #11 - P | | #11 -   |
 | #12 - P | | #12 -   | | #12 - B | | #12 -   |
 | #13 - P | | #13 -   | | #13 - B | | #13 -   |
 | #14 - P | | #14 - B | | #14 -   | | #14 -   |
 | #15 - P | | #15 - B | | #15 -   | | #15 -   |
 | #16 - P | | #16 - B | | #16 -   | | #16 -   |
 +---------+ +---------+ +---------+ +---------+
   5+6=11      6+5=11      5+5=10      0+0=0

Just for ease of demonstration, we will assume that the existing nodes manage to do loadlevel events 
in sequence.  In reality it is far more random though the process is the same.


 +---------+ +---------+ +---------+ +---------+
 | NODE-A  | | NODE-B  | | NODE-C  | | NODE-D  |
 | #1  -   | | #1  -   | | #1  - B | | #1  - P |
 | #2  -   | | #2  - B | | #2  - P | | #2  -   |
 | #3  -   | | #3  - B | | #3  -   | | #3  - P |
 | #4  -   | | #4  - P | | #4  -   | | #4  - B |
 | #5  -   | | #5  - P | | #5  -   | | #5  - B |
 | #6  - B | | #6  - P | | #6  -   | | #6  -   |
 | #7  - B | | #7  - P | | #7  -   | | #7  -   |
 | #8  - B | | #8  - P | | #8  -   | | #8  -   |
 | #9  - B | | #9  -   | | #9  - P | | #9  -   |
 | #10 - B | | #10 -   | | #10 - P | | #10 -   |
 | #11 - B | | #11 -   | | #11 - P | | #11 -   |
 | #12 - P | | #12 -   | | #12 -   | | #12 - B |
 | #13 - P | | #13 -   | | #13 -   | | #13 - B |
 | #14 - P | | #14 -   | | #14 -   | | #14 - B |
 | #15 - P | | #15 -   | | #15 -   | | #15 - B |
 | #16 - P | | #16 - B | | #16 -   | | #16 -   |
 +---------+ +---------+ +---------+ +---------+
   5+6=11      5+3=8       4+1=5       2+6=8

Interestingly, I hadn't considered that when a primary gives a new server a backup copy, another node might end up depleted, so there will be a tiny bit of unnecessary shuffling if that happens.  However, because reality will be a little more random, this effect might be mitigated.

The other thing, if one node has more buckets than another, but there is an inbalance between secondary and primary on the target node, should we still switch some?  Probably, yes.

Ok, we could actually have some problems with shuffling the buckets back and forth, because we are actually removing (backup) buckets from other nodes, and giving it to the node with less capacity.

We can hopefully fix this by keeping track of the loadlevels of the other node and using that information too, or by counting bucket load differently, 

Maybe by switching primary and secondary if it finds an imbalance, instead of sending buckets.  Once the inbalance is fixed, or no switching can take place, then instead do the bucket transfer.



 +---------+ +---------+ +---------+ +---------+
 | NODE-A  | | NODE-B  | | NODE-C  | | NODE-D  |
 | #1  -   | | #1  - B | | #1  - P | | #1  -   |
 | #2  -   | | #2  - B | | #2  - P | | #2  -   |
 | #3  -   | | #3  - P | | #3  - B | | #3  -   |
 | #4  -   | | #4  - P | | #4  - B | | #4  -   |
 | #5  -   | | #5  - P | | #5  - B | | #5  -   |
 | #6  - B | | #6  - P | | #6  -   | | #6  -   |
 | #7  - B | | #7  - P | | #7  -   | | #7  -   |
 | #8  - B | | #8  - P | | #8  -   | | #8  -   |
 | #9  - B | | #9  -   | | #9  - P | | #9  -   |
 | #10 - B | | #10 -   | | #10 - P | | #10 -   |
 | #11 - B | | #11 -   | | #11 - P | | #11 -   |
 | #12 - P | | #12 -   | | #12 -   | | #12 - B |
 | #13 - P | | #13 -   | | #13 - B | | #13 -   |
 | #14 - P | | #14 - B | | #14 -   | | #14 -   |
 | #15 - P | | #15 - B | | #15 -   | | #15 -   |
 | #16 - P | | #16 - B | | #16 -   | | #16 -   |
 +---------+ +---------+ +---------+ +---------+
   5+6=11      6+5=11      5+4=9       0+1=1




****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



Starting again, with the following rules.

   1.  First check the balance of secondary and primary buckets on the target node.  Switch if possible.
   2.  Then check the number of buckets (in total) on target node, send one if we can.
   3.  Only primary buckets can be sent as a backup bucket, original backup is discarded when successful.
   4.  Each node will remember which bucket was last moved (as a backup), and will not allow that 
       bucket to move again until another bucket has moved.

Template

 +---------+ +---------+ +---------+ +---------+
 | NODE-A  | | NODE-B  | | NODE-C  | | NODE-D  |
 | #1  -   | | #1  -   | | #1  -   | | #1  -   |
 | #2  -   | | #2  -   | | #2  -   | | #2  -   |
 | #3  -   | | #3  -   | | #3  -   | | #3  -   |
 | #4  -   | | #4  -   | | #4  -   | | #4  -   |
 | #5  -   | | #5  -   | | #5  -   | | #5  -   |
 | #6  -   | | #6  -   | | #6  -   | | #6  -   |
 | #7  -   | | #7  -   | | #7  -   | | #7  -   |
 | #8  -   | | #8  -   | | #8  -   | | #8  -   |
 | #9  -   | | #9  -   | | #9  -   | | #9  -   |
 | #10 -   | | #10 -   | | #10 -   | | #10 -   |
 | #11 -   | | #11 -   | | #11 -   | | #11 -   |
 | #12 -   | | #12 -   | | #12 -   | | #12 -   |
 | #13 -   | | #13 -   | | #13 -   | | #13 -   |
 | #14 -   | | #14 -   | | #14 -   | | #14 -   |
 | #15 -   | | #15 -   | | #15 -   | | #15 -   |
 | #16 -   | | #16 -   | | #16 -   | | #16 -   |
 +---------+ +---------+ +---------+ +---------+
   0+0=0      0+0=0        0+0=0       0+0=0


So we start with a single node, and it has all the buckets as primary, there are no secondaries.

 +--------+ 
 | NODE-A | 
 | #0 - P | 
 | #1 - P | 
 | #2 - P | 
 | #3 - P | 
 | #4 - P | 
 | #5 - P | 
 | #6 - P | 
 | #7 - P | 
 | #8 - P | 
 | #9 - P | 
 | #A - P | 
 | #B - P | 
 | #C - P | 
 | #D - P | 
 | #E - P | 
 | #F - P | 
 +--------+ 
   16+0=0     

Now we add a second node... it starts out with no buckets.

 +--------+ +--------+
 | NODE-A | | NODE-B |
 | #0 - P | | #0  -  |
 | #1 - P | | #1  -  |
 | #2 - P | | #2  -  |
 | #3 - P | | #3  -  |
 | #4 - P | | #4  -  |
 | #5 - P | | #5  -  |
 | #6 - P | | #6  -  |
 | #7 - P | | #7  -  |
 | #8 - P | | #8  -  |
 | #9 - P | | #9  -  |
 | #A - P | | #A -   |
 | #B - P | | #B -   |
 | #C - P | | #C -   |
 | #D - P | | #D -   |
 | #E - P | | #E -   |
 | #F - P | | #F -   |
 +--------+ +--------+
   16+0=16    0+0=0       

Node A sends a LOADLEVELS request to B, and gets a reply saying "0 primary, 0 secondary".  So A 
starts sending bucket #0 to B as a backup version.  We now have:

 +--------+ +--------+
 | NODE-A | | NODE-B |
 | #0 - P*| | #0 - S |
 | #1 - P | | #1 -   |
 | #2 - P | | #2 -   |
 | #3 - P | | #3 -   |
 | #4 - P | | #4 -   |
 | #5 - P | | #5 -   |
 | #6 - P | | #6 -   |
 | #7 - P | | #7 -   |
 | #8 - P | | #8 -   |
 | #9 - P | | #9 -   |
 | #A - P | | #A -   |
 | #B - P | | #B -   |
 | #C - P | | #C -   |
 | #D - P | | #D -   |
 | #E - P | | #E -   |
 | #F - P | | #F -   |
 +--------+ +--------+
   16+0=0    0+1=1       

Node-A now sees that B has more Secondary buckets than primary, but if it flipped that bucket, then 
there would now be more primary than secondary, so we dont do that.  Only if flipping leaves us with
an even amount, or still more secondaries than primaries.  Since we couldn't flip, A sends another 
bucket to B.

 +--------+ +--------+
 | NODE-A | | NODE-B |
 | #0 - P | | #0 - S |
 | #1 - P*| | #1 - S |
 | #2 - P | | #2 -   |
 | #3 - P | | #3 -   |
 | #4 - P | | #4 -   |
 | #5 - P | | #5 -   |
 | #6 - P | | #6 -   |
 | #7 - P | | #7 -   |
 | #8 - P | | #8 -   |
 | #9 - P | | #9 -   |
 | #A - P | | #A -   |
 | #B - P | | #B -   |
 | #C - P | | #C -   |
 | #D - P | | #D -   |
 | #E - P | | #E -   |
 | #F - P | | #F -   |
 +--------+ +--------+
   16+0=0    0+2=2       

Now when Node-A gets reply from B's loadlevels, it sees that B has more secondary than primary 
buckets, and it is safe to flip one, so it finds the first one that both have, and flips it, this 
time it is bucket #0.

 +--------+ +--------+
 | NODE-A | | NODE-B |
 | #0 - S | | #0 - P |
 | #1 - P*| | #1 - S |
 | #2 - P | | #2 -   |
 | #3 - P | | #3 -   |
 | #4 - P | | #4 -   |
 | #5 - P | | #5 -   |
 | #6 - P | | #6 -   |
 | #7 - P | | #7 -   |
 | #8 - P | | #8 -   |
 | #9 - P | | #9 -   |
 | #A - P | | #A -   |
 | #B - P | | #B -   |
 | #C - P | | #C -   |
 | #D - P | | #D -   |
 | #E - P | | #E -   |
 | #F - P | | #F -   |
 +--------+ +--------+
   15+1=16    1+1=2       

This time things are even, so it sends another bucket.

 +--------+ +--------+
 | NODE-A | | NODE-B |
 | #0 - S | | #0 - P |
 | #1 - P | | #1 - S |
 | #2 - P*| | #2 - S |
 | #3 - P | | #3 -   |
 | #4 - P | | #4 -   |
 | #5 - P | | #5 -   |
 | #6 - P | | #6 -   |
 | #7 - P | | #7 -   |
 | #8 - P | | #8 -   |
 | #9 - P | | #9 -   |
 | #A - P | | #A -   |
 | #B - P | | #B -   |
 | #C - P | | #C -   |
 | #D - P | | #D -   |
 | #E - P | | #E -   |
 | #F - P | | #F -   |
 +--------+ +--------+
   15+1=16    1+2=3       

And we keep doing that until all the buckets have been transferred and things are in balance.

 +--------+ +--------+
 | NODE-A | | NODE-B |
 | #0 - S | | #0 - P |
 | #1 - S | | #1 - P |
 | #2 - S | | #2 - P |
 | #3 - S | | #3 - P |
 | #4 - S | | #4 - P |
 | #5 - S | | #5 - P |
 | #6 - S | | #6 - P |
 | #7 - S | | #7 - P |
 | #8 - P | | #8 - S |
 | #9 - P | | #9 - S |
 | #A - P | | #A - S |
 | #B - P | | #B - S |
 | #C - P | | #C - S |
 | #D - P | | #D - S |
 | #E - P | | #E - S |
 | #F - P*| | #F - S |
 +--------+ +--------+
   8+8=16    8+8=16       

And we are completely balanced.  Bucket #F on Node-A was the last one to be transferred, so it is 
marked internally.

So now what happens when we add another node?

 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 - S | | #0 - P | | #0 -   |
 | #1 - S | | #1 - P | | #1 -   |
 | #2 - S | | #2 - P | | #2 -   |
 | #3 - S | | #3 - P | | #3 -   |
 | #4 - S | | #4 - P | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - P | | #8 - S | | #8 -   |
 | #9 - P | | #9 - S | | #9 -   |
 | #A - P | | #A - S | | #A -   |
 | #B - P | | #B - S | | #B -   |
 | #C - P | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P*| | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   8+8=16     8+8=16     0+0=0      

So we start migrating the buckets to C, because it has less load than the others.

                        
 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 -   | | #0 - S | | #0 - P |
 | #1 -   | | #1 - S | | #1 - P |
 | #2 -   | | #2 - P | | #2 - S |
 | #3 -   | | #3 - P | | #3 - S |
 | #4 -   | | #4 - P*| | #4 - S |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - S | | #8 -   | | #8 - P |
 | #9 - S | | #9 -   | | #9 - P |
 | #A - P | | #A -   | | #A - S |
 | #B - P | | #B -   | | #B - S |
 | #C - P*| | #C -   | | #C - S |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P | | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   6+5=11     6+5=11     4+6=10      

And now we are stable again.  Note that Node-C has 2 more secondaries than primaries.  Normally this 
would trigger a flip, but that cant happen, because the other two nodes will end up reversing their 
own possitions if they flip, so it doesnt happen.  Its ok though.

So now we add a fourth node.

 +--------+ +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C | | NODE-D |
 | #0 -   | | #0 - S | | #0 - P | | #0 -   |
 | #1 -   | | #1 - S | | #1 - P | | #1 -   |
 | #2 -   | | #2 - P | | #2 - S | | #2 -   |
 | #3 -   | | #3 - P | | #3 - S | | #3 -   |
 | #4 -   | | #4 - P*| | #4 - S | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   | | #7 -   |
 | #8 - S | | #8 -   | | #8 - P | | #8 -   |
 | #9 - S | | #9 -   | | #9 - P | | #9 -   |
 | #A - P*| | #A -   | | #A - S | | #A -   |
 | #B - P | | #B -   | | #B - S | | #B -   |
 | #C - P | | #C -   | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   | | #D -   |
 | #E - P | | #E - S | | #E -   | | #E -   |
 | #F - P | | #F - S | | #F -   | | #F -   |
 +--------+ +--------+ +--------+ +--------+
   6+5=11     6+5=11     4+6=10     0+0=0     

The first thing that happens is that A gets a levels msg from D, and it sees that D has less buckets, so sends it one.  Bucket #A.

 +--------+ +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C | | NODE-D |
 | #0 -   | | #0 - S | | #0 - P | | #0 -   |
 | #1 -   | | #1 - S | | #1 - P | | #1 -   |
 | #2 -   | | #2 - P | | #2 - S | | #2 -   |
 | #3 -   | | #3 - P | | #3 - S | | #3 -   |
 | #4 -   | | #4 - P*| | #4 - S | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   | | #7 -   |
 | #8 - S | | #8 -   | | #8 - P | | #8 -   |
 | #9 - S | | #9 -   | | #9 - P | | #9 -   |
 | #A - P*| | #A -   | | #A -   | | #A - S |
 | #B - P | | #B -   | | #B - S | | #B -   |
 | #C - P | | #C -   | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   | | #D -   |
 | #E - P | | #E - S | | #E -   | | #E -   |
 | #F - P | | #F - S | | #F -   | | #F -   |
 +--------+ +--------+ +--------+ +--------+
   6+5=11     6+5=11     4+5=9     0+1=1     

B now happens to get a loadlevels from C, and it sends it a bucket.

 +--------+ +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C | | NODE-D |
 | #0 -   | | #0 - S | | #0 - P | | #0 -   |
 | #1 -   | | #1 - S | | #1 - P | | #1 -   |
 | #2 -   | | #2 - P | | #2 - S | | #2 -   |
 | #3 -   | | #3 - P | | #3 - S | | #3 -   |
 | #4 -   | | #4 - P | | #4 - S | | #4 -   |
 | #5 -   | | #5 - P*| | #5 - S | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   | | #7 -   |
 | #8 - S | | #8 -   | | #8 - P | | #8 -   |
 | #9 - S | | #9 -   | | #9 - P | | #9 -   |
 | #A - P*| | #A -   | | #A -   | | #A - S |
 | #B - P | | #B -   | | #B - S | | #B -   |
 | #C - P | | #C -   | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   | | #D -   |
 | #E - P | | #E - S | | #E -   | | #E -   |
 | #F - P | | #F - S | | #F -   | | #F -   |sqlite
 +--------+ +--------+ +--------+ +--------+
   6+4=10     6+5=11     4+6=10     0+1=1     

It took a backup bucket from A, and gave it to C.
So C now gets a LEVELS from D, and gives it a bucket #0.

 +--------+ +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C | | NODE-D |
 | #0 -   | | #0 -   | | #0 - P*| | #0 - S |
 | #1 -   | | #1 - S | | #1 - P | | #1 -   |
 | #2 -   | | #2 - P | | #2 - S | | #2 -   |
 | #3 -   | | #3 - P | | #3 - S | | #3 -   |
 | #4 -   | | #4 - P*| | #4 - S | | #4 -   |
 | #5 -   | | #5 - P | | #5 - S | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   | | #7 -   |
 | #8 - S | | #8 -   | | #8 - P | | #8 -   |
 | #9 - S | | #9 -   | | #9 - P | | #9 -   |
 | #A - P*| | #A -   | | #A -   | | #A - S |
 | #B - P | | #B -   | | #B - S | | #B -   |
 | #C - P | | #C -   | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   | | #D -   |
 | #E - P | | #E - S | | #E -   | | #E -   |
 | #F - P | | #F - S | | #F -   | | #F -   |
 +--------+ +--------+ +--------+ +--------+
   6+4=10     6+4=10     4+6=10     0+2=2     


Now we continue the migration to see where we end up.

                *                                  
 +--------+ +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C | | NODE-D |
 | #0 -   | | #0 -   | | #0 - P | | #0 - S |
 | #1 -   | | #1 -   | | #1 - P | | #1 - S |
 | #2 -   | | #2 - S | | #2 -   | | #2 - P |
 | #3 -   | | #3 - P*| | #3 - S | | #3 -   |
 | #4 -   | | #4 - P | | #4 - S | | #4 -   |
 | #5 -   | | #5 - P | | #5 - S | | #5 -   |
 | #6 -   | | #6 - P | | #6 - S | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   | | #7 -   |
 | #8 -   | | #8 -   | | #8 - P*| | #8 - S |
 | #9 - S | | #9 -   | | #9 - P | | #9 -   |
 | #A - S | | #A -   | | #A -   | | #A - P |
 | #B - S | | #B -   | | #B -   | | #B - P |
 | #C - P*| | #C -   | | #C -   | | #C - S |
 | #D - P | | #D - S | | #D -   | | #D -   |
 | #E - P | | #E - S | | #E -   | | #E -   |
 | #F - P | | #F - S | | #F -   | | #F -   |
 +--------+ +--------+ +--------+ +--------+
   4+4=8      5+4=9      4+4=8      3+4=7     

And now we've once again finished our process, but we are still flipping buckets around because we 
are out of sync with the number of nodes.

We have two nodes that are perfectly balanced, and two nodes that are node.  The two nodes that are 
not balanced, will attempt to balance by taking a bucket from one of the nodes that is in balance, 
which balances the inbalanced ones, but causes the previously balanced ones now to be out of 
balance, which will cause the bucket to migrate again.

How can we identify this situation?  And how can we rectify it?



                                                   
 +--------+ +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C | | NODE-D |
 | #0 -   | | #0 -   | | #0 -   | | #0 -   |
 | #1 -   | | #1 -   | | #1 -   | | #1 -   |
 | #2 -   | | #2 -   | | #2 -   | | #2 -   |
 | #3 -   | | #3 -   | | #3 -   | | #3 -   |
 | #4 -   | | #4 -   | | #4 -   | | #4 -   |
 | #5 -   | | #5 -   | | #5 -   | | #5 -   |
 | #6 -   | | #6 -   | | #6 -   | | #6 -   |
 | #7 -   | | #7 -   | | #7 -   | | #7 -   |
 | #8 -   | | #8 -   | | #8 -   | | #8 -   |
 | #9 -   | | #9 -   | | #9 -   | | #9 -   |
 | #A -   | | #A -   | | #A -   | | #A -   |
 | #B -   | | #B -   | | #B -   | | #B -   |
 | #C -   | | #C -   | | #C -   | | #C -   |
 | #D -   | | #D -   | | #D -   | | #D -   |
 | #E -   | | #E -   | | #E -   | | #E -   |
 | #F -   | | #F -   | | #F -   | | #F -   |
 +--------+ +--------+ +--------+ +--------+
   0+0=0      0+0=0      0+0=0      0+0=0     


---------------------------------------------------------------------------------

Rules:
   1.  First check the balance of secondary and primary buckets on the target node.  Switch if possible.
   2.  Then check the number of buckets (in total) on target node, send one if we can.
   3.  Only primary buckets can be sent as a backup bucket, original backup is discarded when successful.
   4.  Each node will remember which bucket was last moved (as a backup), and will not allow that 
       bucket to move again until another bucket has moved.
   5.  Before removing a backup bucket, first make sure it wont imbalance the backup node un-necessarily.



Starting off with the state we have with two nodes perfectly balanced, and then we add a third one.
A gets levels from C, and decides to send a bucket.  It chooses bucket #8, and it knows from the 
last level it got from B that B has 8/8 balance.  The 8/8 balance is more in total than C, so it 
agrees to send a backup bucket, removing the one on B.

 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 - S | | #0 - P | | #0 -   |
 | #1 - S | | #1 - P | | #1 -   |
 | #2 - S | | #2 - P | | #2 -   |
 | #3 - S | | #3 - P | | #3 -   |
 | #4 - S | | #4 - P | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - P*| | #8 -   | | #8 - S |
 | #9 - P | | #9 - S | | #9 -   |
 | #A - P | | #A - S | | #A -   |
 | #B - P | | #B - S | | #B -   |
 | #C - P | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P | | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   8+8=16     8+7=15     0+1=1     

So now B gets levels from C, and also decides to send a bucket.  It choses #0, and sees that C has 
less total buckets than A, so will contineu with the transfer.

 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 -   | | #0 - P*| | #0 - S |
 | #1 - S | | #1 - P | | #1 -   |
 | #2 - S | | #2 - P | | #2 -   |
 | #3 - S | | #3 - P | | #3 -   |
 | #4 - S | | #4 - P | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - P*| | #8 -   | | #8 - S |
 | #9 - P | | #9 - S | | #9 -   |
 | #A - P | | #A - S | | #A -   |
 | #B - P | | #B - S | | #B -   |
 | #C - P | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P | | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   8+7=15     8+7=15     0+2=2     

Now A gets levels from C again, and sees that there are more secondaries than primaries.  The only bucket it could switch is #8, but that is marked as the last one to have been migrated, and we dont want to switch that one.  So A sends another one, this time #9.  It can send #9, because B will still have more buckets than C after the transfer.

 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 -   | | #0 - P*| | #0 - S |
 | #1 - S | | #1 - P | | #1 -   |
 | #2 - S | | #2 - P | | #2 -   |
 | #3 - S | | #3 - P | | #3 -   |
 | #4 - S | | #4 - P | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - P | | #8 -   | | #8 - S |
 | #9 - P*| | #9 -   | | #9 - S |
 | #A - P | | #A - S | | #A -   |
 | #B - P | | #B - S | | #B -   |
 | #C - P | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P | | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   8+7=15     8+6=14     0+3=3     

So now B gets levels from C, and sees that C has more secondaries, so it tries to switch one.  #0 is the only one it could switch, but it doesn't, because #0 was the last bucket from B to be transferred.  SO it sends C bucket number #1, which it can do, because A will still have more buckets than C.

 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 -   | | #0 - P | | #0 - S |
 | #1 -   | | #1 - P*| | #1 - S |
 | #2 - S | | #2 - P | | #2 -   |
 | #3 - S | | #3 - P | | #3 -   |
 | #4 - S | | #4 - P | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - P | | #8 -   | | #8 - S |
 | #9 - P*| | #9 -   | | #9 - S |
 | #A - P | | #A - S | | #A -   |
 | #B - P | | #B - S | | #B -   |
 | #C - P | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P | | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   8+6=14     8+6=14     0+4=4     


Node A gets levels from C, and sees more secondaries, and it can now switch #8 because it is a normal bucket.

 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 -   | | #0 - P | | #0 - S |
 | #1 -   | | #1 - P*| | #1 - S |
 | #2 - S | | #2 - P | | #2 -   |
 | #3 - S | | #3 - P | | #3 -   |
 | #4 - S | | #4 - P | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - S | | #8 -   | | #8 - P |
 | #9 - P*| | #9 -   | | #9 - S |
 | #A - P | | #A - S | | #A -   |
 | #B - P | | #B - S | | #B -   |
 | #C - P | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P | | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   7+7=14     8+6=14     1+3=4     

Lets continue on.

                 *    
 +--------+ +--------+ +--------+
 | NODE-A | | NODE-B | | NODE-C |
 | #0 -   | | #0 - S | | #0 - P |
 | #1 -   | | #1 - P | | #1 - S |
 | #2 -   | | #2 - P | | #2 - S |
 | #3 -   | | #3 - P*| | #3 - S |
 | #4 - S | | #4 - P | | #4 -   |
 | #5 - S | | #5 - P | | #5 -   |
 | #6 - S | | #6 - P | | #6 -   |
 | #7 - S | | #7 - P | | #7 -   |
 | #8 - S | | #8 -   | | #8 - P |
 | #9 - S | | #9 -   | | #9 - P |
 | #A - P | | #A -   | | #A - S |
 | #B - P*| | #B -   | | #B - S |
 | #C - P | | #C - S | | #C -   |
 | #D - P | | #D - S | | #D -   |
 | #E - P | | #E - S | | #E -   |
 | #F - P | | #F - S | | #F -   |
 +--------+ +--------+ +--------+
   6+6=12     7+5=12     3+5=8     

